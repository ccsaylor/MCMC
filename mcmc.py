import matplotlib.pyplot as plt
import numpy as np
import scipy.integrate as integrate
import random

class MCMC(object):
    # define constants
    MU = 0
    SIGMA = 1
    NUM_SAMPLES = 100
    INITIAL_GUESS = 1

    # intialize timer
    time = 0

    # intialize empty container for chain values
    chain_values = []

    # generate random samples from a gaussian distribution to act as data from an unknown distribution
    samples = np.random.normal(MU, SIGMA, NUM_SAMPLES)
    sum_of_squares = sum(i * i for i in samples)

    def __init__(self, initial_guess, variance, num_iterations):
        """
        Initializes the Markov chain for the given initial guess, variance, and number of iterations

        Parameters:
        initial_guess: float
            Starting value for the desired parameter
        variance: float
            Variance of the generating function used to generate new parameter values
        num_iterations: int
            Number of chain links to include in the Markov chain
        """

        self.initial_guess = initial_guess
        self.variance = variance
        self.num_iterations = num_iterations

    def posterior_pdf(self, unknown_parameter):
        """
        Definition of the posterior PDF from which the data was drawn

        Parameters:
        unknown_parameter: float
            The parameter being solved for by the algorithm
        """

        return (np.log(unknown_parameter) / (2 * np.pi))**(self.NUM_SAMPLES / 2) * unknown_parameter**(-self.sum_of_squares / 2)

    # def generating_function(self, new_state, current_state):
    #     """
    #     Definition of the generating function used to generate new possible parameter values

    #     Parameters:
    #         new_state: float
    #             the new possible parameter value returned by sampling the generating function
    #         current_state: float
    #             the current parameter value that is stored, replaced if new_state is accepted

    #     """

    #     return 1 / np.sqrt(2 * np.pi * self.variance) * np.exp(-(new_state - current_state)**2 / (2 * self.variance))

    def generate_new_state(self, current_state):
        """
        Generates a candidate state from the generating function

        Parameters:
            current_state: float
                the current parameter value that is stored
        """

        new_state = np.random.normal(current_state, np.sqrt(self.variance))

        return new_state

    def calculate_acceptance_probability(self, new_state, current_state):
        """
        Calculates the acceptance probability of the new state

        Parameters:
            new_state: float
                the new parameter value being tested for acceptance
            current_state: float
                the stored parameter value that new_state is tested against
        """

        return np.amin([1, self.posterior_pdf(new_state)/self.posterior_pdf(current_state)])

    def plot_markov_chain(self):
        """
        Plots the Markov chain generated by the algorithm
        """

        sample_number = [i for i in range(self.num_iterations)]
        plt.plot(sample_number, self.chain_values)
        plt.title("Trace Plot")
        plt.xlabel("Sample Number")
        plt.ylabel("Parameter Value")
        plt.show()


    def iterate(self):
        """
        Iterates the MCMC object for the desired number of iterations
        """
        current_state = self.initial_guess

        for _ in range(self.num_iterations):
            new_state = self.generate_new_state(current_state)
            acceptance_probability = self.calculate_acceptance_probability(new_state, current_state)
            uniform_random_number = np.random.uniform(0, 1)

            if uniform_random_number <= acceptance_probability:
                current_state = new_state

            self.chain_values.append(current_state)
            self.time += 1
        
        self.plot_markov_chain()


markov_chain = MCMC(2, 0.1, 1000) # create an instance of the MCMC class

a = np.linspace(1, 8, 100)
plt.plot(a, markov_chain.posterior_pdf(a)) # plot the posterior PDF
plt.title("Posterior PDF")
plt.xlabel("Parameter Value")
plt.ylabel("Probability Density")
plt.show()

markov_chain.iterate() # iterate the MCMC object to create a Markov chain

fig, ax = plt.subplots(2, 1, sharex=True) # plot the posterior PDF alongside a histogram of chain values to compare their shapes
ax[0].hist(markov_chain.chain_values, 15)
ax[0].set_title("Histogram of Chain Values")
ax[0].set(xlabel='', ylabel='Counts')
ax[1].plot(a, markov_chain.posterior_pdf(a))
ax[1].set_title("Posterior PDF")
ax[1].set(xlabel='Parameter Value', ylabel='Probability Density')
print(np.average(markov_chain.chain_values))
plt.show()
